---
layout: post
title: REST, the big lie
---

# REST, the big lie
Why you might benefit from letting an accepted paradigm rest in peace.

![REST, rest in peace](/images/2015-08-10-rip.jpg)

### REST is awesome, right?
Read a internet developer resume these days, or a corresponding job posting,
and you would think that [REST (Representational State Transfer)](https://en.wikipedia.org/wiki/Representational_state_transfer) interfaces have descended from the heavens as a gift from
The One True Web-developer Deity.

REST-ful APIs are everywhere. Even the marketing folks are pushing REST
as a positive attribute in sales material.  So REST must be great, right?
Before we answer that, let's take a step back and consider what REST is.

### What is REST?
REST originally gained traction when it was recognized as a pattern and
strongly advocated [Roy Fielding](https://en.wikipedia.org/wiki/Roy_Fielding),
who is a notable web luminary.

Roy advocated using the HTTP method (CONNECT, DELETE, GET, HEAD,
OPTIONS, POST, PUT, or TRACE) to impart meaning to a request. 
Thus the following HTTP requests all would have different meanings: 
- `GET /object/list`
- `POST /object/list`
- `PUT /object/list`

Roy also advocated that HTTP response codes be used to communicate the success
status of an API.  This, like the HTTP method vocablary, is quite limited.
Here is a pretty complete list of response codes (I've shortened a few titles
here in the interest of space):

`|------------------------------------------------------------------------|
| 200 OK | 201 Created | 202 Accepted |
| 203 Not authoratative | 204 No content | 205 Reset content |
| 206 Partial content | | |
|------------------------------------------------------------------------|
| 300 Mult-choice | 301 Moved permenantly | |
| 302 Found | 303 See other | 304 Not modified |
| 306 (unused) | 307 Temporary redirect | |
|------------------------------------------------------------------------|
| 400 Bad request | 401 Unauthorized | 402 Payment required |
| 403 Forbidden | 404 Not found | 405 Method not allowed |
| 406 Not acceptable | 407 Proxy auth required | 408 Timeout request |
| 409 Conflict | 410 Gone | 411 Length required |
| 412 Preconditions failed | 413 Request entity too large | |
| 414 Request URI too long | | |
| 415 Unsupported media | 416 Bad request range | 417 Expectation failed |
|------------------------------------------------------------------------|
| 500 Server error | 501 Not implemented | 502 Bad gateway |
| 503 Service unavailable | 504 Gateway timeout | 505 Bad HTTP version |
|------------------------------------------------------------------------|`

So the meaning of any transaction using REST is a combination of the request
verb (e.g GET), the request payload (e.g. the URI string), the response code
(e.g. 202) and the response payload (e.g. a string).

### REST-ful is actually aw-ful
I've worked with REST-like APIs for over 10 years, and in my experience, REST
is one of the worst ideas to ever become common practice in web development.
Many people who publically herald the benefits of REST-ful APIs privately 
loathe using it, and for good reason. Today, I will try to explain what
the problems are, and how a simpler approach to APIs is vastly superior.

### Problem #1: Nobody can agree on a REST convention
Ever notice how nobody calls their API a "pure-REST" convention?  Instead they
call it "REST-ful."  That's because nobody can agree on what REST really
means.

Take a look at the message transactions that can be assembled using HTTP
request methods, payloads, and response codes.  As you might gather, there is
significant debate about what the verbs really mean.  For example should `200
OK` be used to to indicate successful update of a record, or should it be `201
Created`?  As you can see, the vocabulary of this API is limited by these
verbs and response codes, and there is no guarantee that one companies `200
OK` means the same as anothers.  Even if they could agree, we'd still have the
problem that **not all verbs and response codes are universally supported**.

### Problem #2: HTTP support for REST is woefully insufficient
Most client and servers don't support all verbs or response codes.  And, even
when they do, they handle them differently.  For example, most web browsers
historically have not support PUT or DELETE.  Even when they do, many back-end
frameworks don't support them.  So how do we work around this limitation? One
common method is to embed the *intended* verb into a browser form.  Which
means that a REST transaction now includes an HTTP verb, a request payload,
**a verb embedded in the payload to be used instead of the actual HTTP verb**,
and a response code.

It gets even worse: different web browsers have handled non-200 response codes
in very different manners.  For example, if a `307 Temorary redirect` code is
encountered, one browser might allow the client JavaScript to consider this
response *and cancel it* before acting upon it.  Another browser may not.  The
only truly reliable response codes across browsers are 200 and 500.  It's all
down-hill from there.

### Problem #3: REST vocabulary sucks
Even if everyone could agree the meaning of HTTP request and response codes,
**and** all clients and servers supported all of them completely and
consistenly, the vocabulary is both too limited to express all the situations
required for all applicaitons.

Imagine we create an application where we want to send a "render complete"
response back to an HTTP endpoint.  But we can't do that using an HTTP
response code, because **one doesn't exist**.

This too gets worse.  HTTP response codes are numbers (200, 201, 202, etc)
that have no correlation with HTTP request methods, which are verbs.  Yet our
payload is typically in JSON.  So we are using three completely
different vocabularies to communicate a message.  It's like trying to send
snail-mail package adressed in Swahilli, with English content, and a Japanese
receipt.

### Problem #4: REST is awful to debug
If you've ever worked with a REST-ful API, you know they are almost impossible
to debug.  That's because you have to look at 6 different locations to piece
together an entire message transaction: 

- The HTTP request method
- The alternative "this is what we really meant but the client doesn't support it" HTTP method portion of request payload
- The "real data" in the request payload
- The response code
- The alternative "this is what we really meant but the client doesn't support
  it" response code embedded in the response payload
- The "real data" in the response payload

Not only do we have two very limited vocabularies that no one agrees upon or
fully supports, but now we have to look in 6 different places to try to fully
understand and debug a transaction?  This is truly awful.

### Problem #5: REST is not portable
Rest breaks one of the fundamental laws about good communication practices:
the transport medium should be independent of the message.  Certainly 
[Roy Fielding](https://en.wikipedia.org/wiki/Roy_Fielding) had good intentions
when he presented REST as an architecture.  But mixing messages and transport
mechanisms is a time-honored way to confuse those communicating.

Have you ever had to port a REST API to something besides AJAX?  How did that
go for you? 

### The solution
The best way to avoid the problems with REST-ful APIs is not to use REST-ful
APIs.  Instead, use JSON encoding for all error, warning, messages, and data.
This approach is often called a "web API" because it is browser friendly.  And
my experience, it is also much more developer friendly as well.  If you start
with AJAX as your communication mechanism at first, and then slowly migrate to
web-socket connections, you can know with confidence that will need little
work to remain rock-solid.

Web APIs:
- Separate the message from the transmission mechanism
- Rely on only two HTTP request methods: `GET` and `POST`
- Rely on only one HTTP response code: `200 OK` (everything else is considered
  a failure).
- Are easy to debug since transaction information is found in easy-to-read
  single-vocabulary JSON
- Are easily ported to WebSocket, XMPP, SSH, HTTPS, or any other desired transport
  mechanism

### Parting thoughts
I've been challenged numerous times over the last 10 years by the
faithful to use a REST-ful API instead of a WebAPI.  My last major scrap 
with REST being force upon my team was back in 2011.  I have to thank
the server team for agreeing to provide an alternate Web API along side 
their REST-ful API by simply stuffing their *intended* REST methods and
response codes into JSON and only using GET/POST methods and 200/500
responses.

The Web API was faster, more reliable, easier to use, easier to port, 
and much easier to debug.  After a few months, everyone I knew that was using
the REST-ful API moved to the Web API.

