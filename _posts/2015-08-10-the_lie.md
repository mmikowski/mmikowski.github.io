---
layout: post
title: REST, the big lie
---

# REST, the big lie
Why you might benefit from letting an accepted paradigm rest in peace.

![REST, rest in peace](/images/2015-08-10-rip.jpg)

### REST is awesome, right?
If you have read an internet developer resume or job posting in the past 10
years, then you might be forgiven if you think that
[REST] APIs have descended from the heavens as a gift from
The One True Web-developer Deity.  REST-ful APIs are everywhere. 
Even the marketing folks are pushing REST as a positive attribute in sales material.

So how good of an idea is REST really?  Before we answer that, let's look at
where REST came from, and what it is.

### Where did REST come from?
REST originally gained traction when it was promoted by 
[Roy Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)
as part of his doctorial dissertation entitled [Architectural Styles
and the Design of Nework-based Software
Architectures](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm).
Roy was well known for his contributions to development of the web, epecially
the HTTP specification.

### What is REST?
[REST](https://en.wikipedia.org/wiki/Representational_state_transfer) is
Representational State Transfer, and it is an architectural style
intended for for building scalable web services.  
Roy advocated using the request methods he helped define in the HTTP standard
to impart meaning to a request.  Thus the following HTTP requests all
would have different meanings: 

- `GET /object/list`
- `POST /object/list`
- `PUT /object/list`

There are only a few HTTP request methods. The include `CONNECT`, `DELETE`,
`GET`, `HEAD`, `OPTIONS`, `POST`, `PUT`, and `TRACE`.

Roy also advocated that HTTP response codes be used to communicate the meaning
of the response data. There are ~38 HTTP response codes.
Below is complete list where I've shortened a few titles
here in the interest of space:

`|------------------------------------------------------------------------|
| 200 OK | 201 Created | 202 Accepted |
| 203 Not authoratative | 204 No content | 205 Reset content |
| 206 Partial content | | |
|------------------------------------------------------------------------|
| 300 Mult-choice | 301 Moved permenantly | |
| 302 Found | 303 See other | 304 Not modified |
| 306 (unused) | 307 Temporary redirect | |
|------------------------------------------------------------------------|
| 400 Bad request | 401 Unauthorized | 402 Payment required |
| 403 Forbidden | 404 Not found | 405 Method not allowed |
| 406 Not acceptable | 407 Proxy auth required | 408 Timeout request |
| 409 Conflict | 410 Gone | 411 Length required |
| 412 Preconditions failed | 413 Request entity too large | |
| 414 Request URI too long | | |
| 415 Unsupported media | 416 Bad request range | 417 Expectation failed |
|------------------------------------------------------------------------|
| 500 Server error | 501 Not implemented | 502 Bad gateway |
| 503 Service unavailable | 504 Gateway timeout | 505 Bad HTTP version |
|------------------------------------------------------------------------|`

The meaning of any transaction using a REST style is therefore the result of
the HTTP request method verb (e.g GET), the request payload (e.g. the URI string),
the response code (e.g. 202) and the response payload (e.g. a string).

### REST-ful is actually awful
I've worked with REST-ful APIs since they've first emerged, and find 
them one of the worst ideas to ever become common practice in 
modern web software.

with no direspect to Roy for whom I hold no malice. 

Many people who publically herald the benefits of REST-ful APIs privately 
loathe using it, and for good reason. Today, I will try to explain what
the problems are, and how a simpler approach to APIs is vastly superior.

### Problem #1: Nobody can agree on a REST convention
Ever notice how nobody calls their API a "pure-REST" convention?  Instead they
call it "REST-ful."  That's because nobody can agree on what REST really
means.

Take a look at the message transactions that can be assembled using HTTP
request methods, payloads, and response codes.  As you might gather, there is
significant debate about what the verbs really mean.  For example should `200
OK` be used to to indicate successful update of a record, or should it be `201
Created`?  As you can see, the vocabulary of this API is limited by these
verbs and response codes, and there is no guarantee that one companies `200
OK` means the same as anothers.  Even if they could agree, we'd still have the
problem that **not all verbs and response codes are universally supported**.

### Problem #2: HTTP support for REST is woefully insufficient
Most client and servers don't support all verbs or response codes.  And, even
when they do, they handle them differently.  For example, most web browsers
historically have not support PUT or DELETE.  Even when they do, many back-end
frameworks don't support them.  So how do we work around this limitation? One
common method is to embed the *intended* verb into a browser form.  Which
means that a REST transaction now includes an HTTP verb, a request payload,
**a verb embedded in the payload to be used instead of the actual HTTP verb**,
and a response code.

It gets even worse: different web browsers have handled non-200 response codes
in very different manners.  For example, if a `307 Temorary redirect` code is
encountered, one browser might allow the client JavaScript to consider this
response *and cancel it* before acting upon it.  Another browser may not.  The
only truly reliable response codes across browsers are 200 and 500.  It's all
down-hill from there.

### Problem #3: REST vocabulary sucks
Even if everyone could agree the meaning of HTTP request and response codes,
**and** all clients and servers supported all of them completely and
consistenly, the vocabulary is both too limited to express all the situations
required for all applicaitons.

Imagine we create an application where we want to send a "render complete"
response back to an HTTP endpoint.  But we can't do that using an HTTP
response code, because **one doesn't exist**.

This too gets worse.  HTTP response codes are numbers (200, 201, 202, etc)
that have no correlation with HTTP request methods, which are verbs.  Yet our
payload is typically in JSON.  So we are using three completely
different vocabularies to communicate a message.  It's like trying to send
snail-mail package adressed in Swahilli, with English content, and a Japanese
receipt.

### Problem #4: REST is awful to debug
If you've ever worked with a REST-ful API, you know they are almost impossible
to debug.  That's because you have to look at 6 different locations to piece
together an entire message transaction: 

- The HTTP request method
- The alternative "this is what we really meant but the client doesn't support it" HTTP method portion of request payload
- The "real data" in the request payload
- The response code
- The alternative "this is what we really meant but the client doesn't support
  it" response code embedded in the response payload
- The "real data" in the response payload

Not only do we have two very limited vocabularies that no one agrees upon or
fully supports, but now we have to look in 6 different places to try to fully
understand and debug a transaction?  This is truly awful.

### Problem #5: REST is not portable
Rest breaks one of the fundamental laws about good communication practices:
the transport medium should be independent of the message.  Certainly 
[Roy Fielding](https://en.wikipedia.org/wiki/Roy_Fielding) had good intentions
when he presented REST as an architecture.  But mixing messages and transport
mechanisms is a time-honored way to confuse those communicating.

Have you ever had to port a REST API to something besides AJAX?  How did that
go for you? 

### The solution
The best way to avoid the problems with REST-ful APIs is to use a Web API.
A Web API:

- Relies on just one transmission method to send a request - typically `POST`
  for HTTP.
- Completely separates the request message from the transmission mechanism.  All
  errors, warnings, and data are placed in the JSON request payload.
- Rely on only one response code to confirm proper receipt of a message - 
  typically `200 OK` for HTTP.
- Completely separates the response message from the transmission mechanism
  and places all errors, warnings, and data in the JSON response payload.
- Is easy to debug since transaction information is found in easy-to-read
  JSON using a single, domain specific vocabulary.
- Can easily be ported to another transmission protocol such as 
  WebSocket, XMPP, telnet, SFTP, SCP, or SSH.
  
The name Web API came about because web developers found that REST-ful APIs
are not very browser or developer friendly. The separation of message and
transmission resulted in an API delivery style that is usually faster, more reliable,
easier to use, easier to port, and easier to debug. 

### Parting thoughts
I've been challenged numerous times over the last 10 years by the
faithful to use a REST-ful API instead of a Web API. 
The last time I nearly had to support a REST-ful API was in 2011.  Thankfully,
the server team agreed to provide an alternate Web API along side 
the REST-ful API by simply stuffing their *intended* HTTP methods and
response codes into JSON. After a few months, everyone I knew 
had switched to the Web API.

