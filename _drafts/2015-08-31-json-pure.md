---
layout: post
title: JSON Pure APIs
---
*Using JSON and websockets*

![JSON for application content](/images/2015-08-31-json-pure.png)

### JSON Pure APIs

[RESTful APIs, the big lie](the_lie) challenged the widely-held belief 
that RESTful APIs provide a robust mechanism for modern web applications.
I was inspired to write that post for two reasons.  First, I am working on a new
API for a new SPA, and second, we are hiring a develoment team and I was suprised 
by how much emphasis the candidates placed on RESTful APIs without considering
the costs and benefits.

My goal was to provide an objective, easy to ready, and well-ordered list of
issues with RESTful APIs.  In other words, I wanted to clearly define the
problem before suggesting a solution.

The summary discussed using a solution that I called **JSON-Pure APIs** 
to overcome the problems that were listed. _This is just a name I used here for
convenience_; there isn't an official standard, although I've been influenced by
many like XML, JSON RPC, JSON Schema, JSON API, JSON LD, SOAP, and Hydra.

What follows are the best practices I've acquired over years 
developing **JSON-Pure APIs** for
[Single Page web Applications](http://www.amazon.com/Single-Page-Applications-end---end/dp/1617290750):

- **Use a well-defined vocabulary**
- **Use asynchronous transactions**
- **Use a reliable request method**
- **Separate the request from the transport**
- **Use a reliable response method**
- **Separate the response from the transport**
- **Make it easy to debug**
- **Make it portable**

This is just slightly expanded from the summary of
[RESTful APIs, the big lie](the_lie). We will go into detail for each one.
Let's look at the vocabulary first.

### Use a well-defined vocabulary

A good API uses a vocabulary that is widely understood with relatively little
nuance.

#### General structure


#### Application messages

All the messages an application (server or client) sends in a response is
placed in a `log_list`. The JSON below shows all available log levels.

    { log_list: [
        { level_int : 0, level_str : "debug" /* detail */ },
        { level_int : 1, level_str : "info",  },
        { level_int : 2, level_str : "log",   },
        { level_int : 3, level_str : "warn",  },
        { level_int : 4, level_str : "error", }
      ],
      /* ... */
    }

    /* detail: id, code_key, code_str, user_msg */

The `level_int` value is useful to implement log filtering, either for the
recepient, or during a request (e.g. `log_level_int : 3` ).

#### Action verbs

The CRUD set of verbs is about as widely understood as it gets.  This is what
I recommend:

| Request  | Response  | Confirm  |
|----------|-----------|----------|
| create   | CREATED   | ok, deny |
| retreive | RETREIVED | ok, deny |
| update   | UPDATED   | ok, deny |
| delete   | DELETED   | ok, deny |
| flush    | FLUSHED   | ok, deny |

Server responses are UPPERCASE to help differentiate them. Responses are directly
correlated with requests.  While at first glance this may appear almost trite,
it actually is quite important and useful.  Consider API designs that use
_unsolicited responses_ to keep clients in-sync with with server data. In this
case, each client that needs to be notified of data change is sent a CREATED
or UPDATED or DELETED message whenever necessary.

We added the **flush** verb so the client can tell the server when it
has removed data from its storage.  Thus when the server sends out updates, it
doesn't have to worry about clients that **flush**ed records.

Finally, we are using a `request-response-confirm` transaction instead of a
`request-response` transaction.  Let's discuss that next.


### Use asynchronous transactions

Many web sites to this day are driven by the server. The browser
client is a **content consumption device** that displays HTML text and graphics.
We **want** this classic client-server approach for displaying content like
blog pages because it is simple, clean, and well-understood. 

The RESTful `request-response` transaction makes a great deal when the web browser is
a **content consumption device**.  The transaction is *blocking* in that the web
browser can't be used until all the content is received.  That's fine
because we've optimized the delivery so that it only takes a few seconds.

SPAs, however, are better served by `request-response-confirm` transactions.
For example, if a client `requests` a resource, the server issues a `response`.
Once the client has received and _processed_ the response, it will send a 
`confirm` to the server.

The benefits of the `request-response-confirm` transaction include:

- The confirmation goes beyond the _transport status_ -- was the message
  received? -- and reports to the server the _application status_ of the message
  -- was the message properly processed and consumed?  This is very important 
  for an SPA so the server may keep track of client data sets.

- The transaction is asynchronous. The client, for example, may take 20
  seconds to consume a large data set; or perhaps the client may wait for
  user approval before processing or denying a provided data set. 
  During this time, the server can continue to process other requests without
  maintaining an open connection.  Implementing such a delay over a typical
  RESTful `request-response` can be difficult and expensive.

### Use a reliable request method

When we send an API request, we use a single, reliable, well-supported 
method.  We don't embed any application meaning into the method. 
This ensures the most reliable delivery of the request.  An API request
is either transported correctly or it isn't.  There is little ambiguity due to
the vagaries of server or client software support.

What this method is depends on the transport.  Typically `POST`
is used for HTTP and `send` for WebSockets.

### Separate the request from the transport

#### The endpoint

Keep your endpoint limited to the API application description.  For example:

    https://api.mycompany.com/3-1-a/

The address is limited to the API source location and the version number.

This will prevent HTTP caching of responses, but do we really care? 
The purpose of an an API is to communicate between dynamic client and server
applications.  Transfer of bulk data and caching can be done at many levels,
and we can leverage the good parts of HTTP and REST for such purposes.
For example, instead of delivering image data over our API, we can instead
provide a URL to a cachable PNG image.

#### The transaction map

    { "trans_map"  : { /* transaction details here */},
      "action_str" : "update",
      "data_type"  : "person",
      "data_id"    : "eb99ec08-7e90-400d-9585-62a1385ec158",
      "data_map"   : { /* updated details here */ },
    }

### Use a reliable response method
### Separate the response from the transport
### Make it easy to debug
### Make it portable

An application API should be easily portable over any transport method such as
HTTP/S, WebSockets, XMPP, telnet, SFTP, SCP, or SSH. An API developed with
these best practices is nearly transport neutral, and should require only
minor tweaks to work over nearly any transport.

