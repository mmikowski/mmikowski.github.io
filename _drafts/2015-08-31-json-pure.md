---
layout: post
title: JSON Pure APIs
---
*Using JSON and websockets*

![JSON for application content](/images/2015-08-31-json-pure.png)

### How did we get here?
[RESTful APIs, the big lie](the_lie) challenged the widely-held belief
that **RESTful APIs** provide a robust mechanism for modern web applications.
The inspiration to write that post came from two sources.  First, we
were writing an new API for an SPA, so the topic was certainly at the top of
my mind.  Second, we are hiring a develoment team members, and the
candidates placed a surprising amount of emphasis and awe on **RESTful APIs**.

#### Here's the sequal
The goal of [the big lie](the_lie) therefore was to provide an objective,
easy to ready, and well-ordered list of issues with **RESTful APIs**.
In other words, the goal was to clearly define the problem before
suggesting a solution.

This post picks up where [the big lie](the_lie) finished and looks at some
best API practices when freed from the constraints of REST. However, before we do
let's clear up big misconception many readers had about the original post.

#### REST is good
**REST** content delivery is going to be around for a long time because it works
very well and we have an excellent and expensive infrastructure built around it.
I've never disputed this.  The original post, for example contains this sentence:

> **REST** is a great mechanism for many things such as content delivery, and it
> has served us well for two decades.

I stand by that statement. But I had made a mistake in the original post: I
had titled it  **REST, the big lie** instead of **RESTful APIs, the big lie**.
I recognized the original title was too broad, but by the time I had fixed the
mistake a few hours later the damage had been done: search engines, links,
and the social networks kept the original name.

So let me be clear, **REST** is good. **RESTful APIs**, not so much.

#### RESTful APIs, not so much
The **big lie** about **RESTful APIs** is the commonly held belief that
the are almost always the best choice for internet APIs.  They are not, and
are particularly ill-suited for modern web applications like SPAs.
Most of issues are detailed in the [earlier post](the_lie), and we are not going
to rehash them here.


Now, let's take a look at some best practices.

### JSON-Pure best practices

[RESTful APIs, the big lie](the_lie) concluded with a list of best-practices
that I've seen over 8 years developing non-RESTful APIS for [Single Page web Applications](http://www.amazon.com/Single-Page-Applications-end---end/dp/1617290750).
I referred to these practices as **JSON-Pure APIs**. This is **not** an official
standard, it's just a name I made of for sake of _brevity and convenience_.

My primary going when developing an SPA API is provide an application
with the best possible user experience.  Following a standard is a
secondary consideration. Certainly, what I outline below is nothing new or
revolutionary. You will see echos of SOAP, JSON RPC, JSON Schema, JSON API,
JSON LD, and Hydra, and probably a few other dozen standards I somehow missed.

Sometimes, though, putting everything in one place has a lot of value.
In this spirit, I will now share with you, free of charge, many of my SPA API
best practices:

- Use a well-defined vocabulary
- Use four message types
- Use asynchronous transactions
- Use a reliable request method
- Separate the request from the transport
- Use a reliable response method
- Separate the response from the transport
- Make it easy to debug
- Make it portable

This is just slightly expanded from the summary of [the big lie](the_lie).
Let's look at each in detail, starting with the vocabulary.

### Use a well-defined vocabulary

The best APIs adopts vocabulary and structure that is widely understood
with relatively little nuance.  Reusing existing language and structure
greatly reduces the cognitive overhead for consumers of the API.

#### Use universal action verbs
The CRUD set of verbs is about as widely understood as it gets.
Here is a recommendation of action verbs for Requests, Responses,
and Confirmations:

| Request  | Response                 | Confirmation       |
|----------|--------------------------|--------------------|
| create   | CREATED,  CREATE\_FAIL   | abort, done, retry |
| retreive | RETREIVED,RETREIVE\_FAIL | abort, done, retry |
| update   | UPDATED,  UPDATE\_FAIL   | abort, done, retry |
| delete   | DELETED,  DELETE\_FAIL   | abort, done, retry |
| flush    | FLUSHED,  FLUSH\_FAIL    | abort, done, retry |

Server action verbs UPPERCASE to help differentiate them. Response verbs are directly
correlated with request verbs.  While at first glance this may appear almost trite,
it actually is quite important and useful, as we shall see when we discuss
*indirect responses* below.

We added the **flush** verb so the client can tell the server when it
has removed data from its storage.  Thus when the server distributes
notification of changed records, it doesn't have to send messages to clients
that have **flush**ed the containing data set.

#### Use familiar application logging

All the messages an application (server or client) sends in a response is
placed in a `log_list`. The JSON below shows all available log levels.

    { log_list: [
        { level_int : 0, level_str : "debug" /* detail */ },
        { level_int : 1, level_str : "info",  },
        { level_int : 2, level_str : "log",   },
        { level_int : 3, level_str : "warn",  },
        { level_int : 4, level_str : "error", }
      ],
      /* ... */
    }

    /* detail: log_id, code_key, code_str, user_msg */

The `level_int` value is useful to implement log filtering, either for the
recepient, or during a request.

Here is an example of a full error message:

    [ { code_key  : "400",
        code_str  : "Bad request",
        level_int : 4,
        level_str : "error",
        log_id    : "1096",
        user_msg  : "action_str required"
      }
    ]

Notice how we mapped a REST code to the error.  We do that for convenience and
familiarity.  However, we generally use the REST error codes as a subset of
our full vocabulary, since we can extend it as the application requires.

### Use four message types

SPA APIs generally require four message types:

1. Requests
2. Direct responses
3. Indirect responses
4. Confirmations

#### Requests

Requests are messages sent from clients requesting data manipulation or delivery.
An example request to change a specific record would have the `update`
action verb.

#### Direct responses

Direct responses are messages from the server to attached clients directly
in response to a request. A direct response to the `update` request in the
example would use the `UPDATED` action verb.

#### Indirect responses

Indirect responses are broadcast from the server to clients without a 
direct corresponding request.  This happens when the server changes a record
and notifies clients with out-of-date data.  An indirect response to for
the example above would have an `UPDATED` action verb.

#### Confirmations

Confirmations are sent from the clients to the application confirming a response
has been received **and processed** by the client application.
The client may indicate success with **done**, cancel the transaction with
**abort** or request a resubmission with **retry**.  Generally it is a good
idea to avoid the complexities of supporting the idea of "partial success".

### Use a standard message struture

API messages should have a standard, minimal structure that is consistent and
easy to read. It is useful to name the properities to indicate data type.
Here is a minimal recommended message structure:

    // request
    { action_str    : "retrieve",  /* action verb */
      data_type     : "person",    /* record data */
      log_list      : [ /* application messages */  ],
      request_map   : { /* request parameters   */  },
      trans_map     : { /* transaction metadata */  }
    }

    // response
    { action_str    : "RETRIEVED", /* action verb */
      data_type     : "person",    /* record data */
      log_list      : [ /* application messages */  ],
      response_list : { /* returned data */ },
      trans_map     : { /* transaction metadata */ }
    }

    // confirm
    { action_str    : "done",      /* action verb */
      data_type     : "person",    /* record data */
      log_list      : [ /* application messages */  ],
      confirm_map   : { /* confirmation details */ },
      trans_map     : { /* transaction metadata */ }
    }

Multiple messages may be aggregated by placing them in an array, like so:

    [ { /* message 1 */ },
      { /* message 2 */ },
      ....
    ]

The action verb, `action_str` is discussed in its own section above.
Every request should have one.

The `data_type` indicator is applicaiton dependent.

The application messages list, `log_list`, is discussed in its own section
above.

The `trans_map` is map (surprise!) of transaction specific parameters.
The identifying properties do not change through a transaction life cycle.
Therefore the `request`, `response`, and `confirm` messages for a single
transaction will have the same `trans_map` for a single client.

    trans_map  : {
      auth_key : "c76aa3577f8b5a60206f9d041c76034a",
      trans_id : "eb99ec08-7e90-400d-9585-62a1385ec158"
    }

That's correct - we are sending our `auth_key` in our messages.
This should be at least as secure as a typical shared secret-cookie.

#### Use schema validation

Once a vocabulary is selected, we need to ensure it is correctly implemented.
We should write a [JSON-Schema](http://json-schema.org/) so that we may validate
messages both during debugging and during message passing.

This isn't hard to implement, and it helps avoid silly and gnarly errors that
occur when malformed messages are parsed.

### Use asynchronous transactions

You may have noticed that these practices suggest using `request-response-confirm`
instead of `request-response` transactions.   There's a reason for that.

#### Use request-response when appropriate
Many web sites to this day are driven by the server. The browser
client is a **content consumption device** that displays HTML text and graphics.
We **want** this classic client-server approach for displaying content like
blog pages because it is simple, clean, and well-understood.

The RESTful `request-response` transaction makes a great deal when the web browser is
a **content consumption device**.  The transaction is *blocking* in that the web
browser can't be used until all the content is received.  That's fine
because we've optimized the delivery so that it only takes a few seconds.

#### Use request-response-confirm for APIs
SPAs, however, are better served by `request-response-confirm` transactions.
For example, if a client `requests` a resource, the server issues a `response`.
Once the client has received and _processed_ the response, it will send a
`confirm` to the server.

The benefits of the `request-response-confirm` transaction include:

- The confirmation goes beyond the _transport status_ -- was the message
  received? -- and reports to the server the _application status_ of the message
  -- was the message properly processed and consumed?  This is very important
  for an SPA so the server may keep track of client data sets.

- The transaction is asynchronous. The client, for example, may take 20
  seconds to consume a large data set; or perhaps the client may wait for
  user approval before processing or denying a provided data set.
  During this time, the server can continue to process other requests without
  maintaining an open connection.  Implementing such a delay over a typical
  RESTful `request-response` can be difficult and expensive.

As suggested earlier, `request-response` transaction is **preferred** if that is
that is required. But if we need to sync records between a rich client and server,
the `request-response-confirm` cycle is often the best option.

### Use a reliable request method

Don't embed any application meaning into the transport request method.
Instead, use the single, most reliable request method available.

On the transport layer, we are simply concerned about whether an API message is
successfuly transferred or not.  Think of the transport layer as the UPS
driver of web traffic: He will make sure your new sweater gets delivered
(transport issue), but he's not going to sit around for hours while you decide
if you like it or not (application issue).

### Separate the request from the transport

#### Use a simple endpoint

Keep your endpoint limited to the API application description.  For example:

    https://api.mycompany.com/3-1-a/

The address is limited to the API source location and the version number.

This will prevent HTTP caching of responses.  But do we really care?
The purpose of an an API is to communicate between dynamic client and server
applications.  Transfer of bulk data and caching can be done at many levels,
and we can leverage the good parts of HTTP and REST for such purposes.
For example, instead of delivering image data over our API, we can instead
provide a URL to a cachable PNG image.

#### Put application transaction details in the messages

We earlier detailed a transaction map, but here it is again:

    trans_map  : {
      auth_key : "c76aa3577f8b5a60206f9d041c76034a",
      trans_id : "eb99ec08-7e90-400d-9585-62a1385ec158"
    }

A transaction may require additional details not shown here, but this
is a good starting point.  The `trans_id` should be generated by the original
request, and should be immutable throughout the transaction.  The `auth_key`
will vary by implementation and client.  Also, the example string I show here is
probably far too short for a good shared secret.

### Use a reliable response method

Don't embed any application meaning into the transport response method.
Again, on the transport layer we are simply concerned about whether an API
message is successfuly transferred or not.  Just use the single, most
reliable response method available.

What this method is depends on the transport.  Typically we use a 200 OK
response for HTTP and `send` for WebSockets.

### Separate the response from the transport

The response format as illustrated above keeps all application-level details
in the JSON message.  At this point, we can just coast.

### Make it easy to debug

All the details discussed above makes the messages very easy to debug.  All
application specific meaning is encoded in the JSON, so debugging becomes much
easier.  First we can inspect the transport to determine if a message is sent
or not.  Then we can inspect the JSON for any and all applicaiton specific
issues.

JSON-schema validation is also very useful to help debug the API.  Use of a
command-line driven JSON-schema checking utility is very helpful during
development.

Finally, consider adding a suffix to JSON keys to indicate type.  This aids
greatly in discoverablility at little cost.  Avoid using a plural noun as a key,
because it is very ambiguous.  Instead of `persons` use `person_list` or
`person_map` or `is_person` instead.

### Make it portable

An application API should be easily portable over any transport method such as
HTTP/S, WebSockets, XMPP, telnet, SFTP, SCP, or SSH. An API developed with
these best practices is nearly transport neutral, and should require only
minor tweaks to work over nearly any transport.

### Closing thoughts

Throughout this post the implied transport was WebSockets and the payload was
JSON.  Many of the same principles can be applied regardless of transport or
data interchange format.  However these are the two I recommend today.

I hope you found this useful, and as always, all feedback is welcome!

Cheers, Mike

===== cut ======
#### The move away from RESTful APIs is already happening
Many companies have and will be moving to WebSockets APIs because
it is ~4-20x faster than HTTP and it supports inexpensive,
fast, asynchronous, full-duplex messaging.  All of these attributes are extremely
compelling for SPAs. Yet there is only only one `send()` method in WebSockets and
no visible response codes to view in web server logs.  In other words, WebSocket
APIs are **decidely not RESTful**, yet they are gaining adoptions rapidly, for
very good reasons.

I expect that **REST** will continue to be used for the majority of web
traffic, especially content distribution.  However, many **APIs** will move to
more appropriate, non-RESTful design patterns.
